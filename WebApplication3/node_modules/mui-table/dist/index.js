"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getHeaders", {
  enumerable: true,
  get: function get() {
    return _utils.getHeaders;
  }
});
Object.defineProperty(exports, "getColumns", {
  enumerable: true,
  get: function get() {
    return _utils.getColumns;
  }
});
exports["default"] = exports.useStyles = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _clsx3 = _interopRequireDefault(require("clsx"));

var _styles = require("@material-ui/core/styles");

var _Table = _interopRequireDefault(require("@material-ui/core/Table"));

var _TableBody = _interopRequireDefault(require("@material-ui/core/TableBody"));

var _TableCell = _interopRequireDefault(require("@material-ui/core/TableCell"));

var _TableFooter = _interopRequireDefault(require("@material-ui/core/TableFooter"));

var _TableHead = _interopRequireDefault(require("@material-ui/core/TableHead"));

var _TablePagination = _interopRequireDefault(require("@material-ui/core/TablePagination"));

var _TableRow = _interopRequireDefault(require("@material-ui/core/TableRow"));

var _TableSortLabel = _interopRequireDefault(require("@material-ui/core/TableSortLabel"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var resolveProp = function resolveProp(prop, args) {
  return typeof prop === "function" ? prop(args) : prop;
};

var useStyles = (0, _styles.makeStyles)(function (theme) {
  return {
    container: {},
    tableWrapper: {},
    cellSelected: {
      backgroundColor: theme.palette.grey[100]
    },
    cellHovered: {
      backgroundColor: theme.palette.grey[200]
    }
  };
});
exports.useStyles = useStyles;

function MuiTable(props) {
  var data = props.data,
      columns = props.columns,
      containerProps = props.containerProps,
      tableWrapperProps = props.tableWrapperProps,
      headerProps = props.headerProps,
      bodyProps = props.bodyProps,
      rowProps = props.rowProps,
      headerRowProps = props.headerRowProps,
      bodyRowProps = props.bodyRowProps,
      defaultCellProps = props.cellProps,
      defaultHeaderCellProps = props.headerCellProps,
      defaultBodyCellProps = props.bodyCellProps,
      includeHeaders = props.includeHeaders,
      onHeaderClick = props.onHeaderClick,
      onCellClick = props.onCellClick,
      isCellHovered = props.isCellHovered,
      isCellSelected = props.isCellSelected,
      pagination = props.pagination,
      addPlaceholderRows = props.addPlaceholderRows,
      orderBy = props.orderBy,
      orderDirection = props.orderDirection,
      tableProps = _objectWithoutProperties(props, ["data", "columns", "containerProps", "tableWrapperProps", "headerProps", "bodyProps", "rowProps", "headerRowProps", "bodyRowProps", "cellProps", "headerCellProps", "bodyCellProps", "includeHeaders", "onHeaderClick", "onCellClick", "isCellHovered", "isCellSelected", "pagination", "addPlaceholderRows", "orderBy", "orderDirection"]);

  var _useState = (0, _react.useState)({
    hoveredColumn: null,
    hoveredRowData: null
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var classes = useStyles();
  var hoveredColumn = state.hoveredColumn,
      hoveredRowData = state.hoveredRowData;
  return _react["default"].createElement("div", _extends({
    className: classes.container
  }, containerProps), _react["default"].createElement("div", _extends({
    className: classes.tableWrapper
  }, tableWrapperProps), _react["default"].createElement(_Table["default"], tableProps, includeHeaders && _react["default"].createElement(_TableHead["default"], headerProps, (0, _utils.getHeaders)(columns).map(function (headerRow, headerRowIndex) {
    return _react["default"].createElement(_TableRow["default"], _extends({}, resolveProp(rowProps, {
      column: {},
      rowData: {},
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(headerRowProps, {
      column: {},
      rowData: {},
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), {
      key: "header-row-".concat(headerRowIndex)
    }), headerRow && headerRow.map(function (column, columnIndex) {
      var _clsx;

      var contents = column.header || column.name;
      var isHovered = hoveredColumn && hoveredRowData && isCellHovered && isCellHovered({
        column: column,
        rowData: {},
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      });
      var isSelected = isCellSelected && isCellSelected({
        column: column,
        rowData: {}
      });
      var className = (0, _clsx3["default"])((_clsx = {}, _defineProperty(_clsx, classes.cellHovered, isHovered), _defineProperty(_clsx, classes.cellSelected, isSelected), _clsx));
      var cellProps = (0, _utils.merge)({}, {
        className: className
      }, resolveProp(defaultCellProps, {
        column: column,
        rowData: {},
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: {},
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultHeaderCellProps, {
        column: column,
        rowData: {},
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.headerCellProps, {
        column: column,
        rowData: {},
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      return _react["default"].createElement(_TableCell["default"], _extends({}, isCellHovered && {
        onMouseEnter: function onMouseEnter() {
          setState({
            hoveredColumn: column,
            hoveredRowData: {}
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setState({
            hoveredColumn: null,
            hoveredRowData: null
          });
        }
      }, {
        key: "header-cell-".concat(column.name),
        colSpan: column.colSpan,
        rowSpan: column.rowSpan
      }, cellProps), column.orderBy !== false && column.onHeaderClick !== false && (column.onHeaderClick || onHeaderClick) ? _react["default"].createElement(_TableSortLabel["default"], {
        active: orderBy && (orderBy === column.name || orderBy === column.orderBy),
        style: {
          width: "inherit"
        } // fix text overflowing
        ,
        direction: orderDirection,
        onClick: function onClick() {
          return column.onHeaderClick ? column.onHeaderClick() : onHeaderClick({
            column: column
          });
        }
      }, contents) : contents);
    }));
  })), _react["default"].createElement(_TableBody["default"], bodyProps, data && data.map(function (rowData, rowIndex) {
    return _react["default"].createElement(_TableRow["default"], _extends({
      key: "body-row-".concat(rowIndex)
    }, resolveProp(rowProps, {
      column: {},
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(bodyRowProps, {
      column: {},
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    })), (0, _utils.getColumns)(columns).map(function (column, columnIndex) {
      var _clsx2;

      var contents = column.cell ? column.cell(rowData, rowIndex) : rowData[column.name];
      var isHovered = hoveredColumn && hoveredRowData && isCellHovered && isCellHovered({
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      });
      var isSelected = isCellSelected && isCellSelected({
        column: column,
        rowData: rowData
      });
      var className = (0, _clsx3["default"])((_clsx2 = {}, _defineProperty(_clsx2, classes.cellHovered, isHovered), _defineProperty(_clsx2, classes.cellSelected, isSelected), _clsx2));
      var cellProps = (0, _utils.merge)({}, {
        className: className
      }, resolveProp(defaultCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultBodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.bodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      return _react["default"].createElement(_TableCell["default"], _extends({
        style: _objectSpread({}, (onCellClick || column.onClick) && {
          cursor: "pointer"
        })
      }, isCellHovered && {
        onMouseEnter: function onMouseEnter() {
          setState({
            hoveredColumn: column,
            hoveredRowData: rowData
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setState({
            hoveredColumn: null,
            hoveredRowData: null
          });
        }
      }, onCellClick && {
        onClick: function onClick() {
          if (window.getSelection().toString() == "") {
            onCellClick({
              column: column,
              rowData: rowData
            }); // Can be overridden by cellProps.onClick on column definition
          }
        }
      }, {
        key: "body-cell-".concat(rowIndex, "-").concat(column.name)
      }, cellProps), contents);
    }));
  }), pagination && addPlaceholderRows && pagination.rowsPerPage > (data ? data.length : 0) && Array.from({
    length: pagination.rowsPerPage - (data ? data.length : 0)
  }).map(function (rowData, rowIndex) {
    return _react["default"].createElement(_TableRow["default"], _extends({}, resolveProp(rowProps, {
      column: {},
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(bodyRowProps, {
      column: {},
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), {
      key: "body-row-placeholder-".concat(rowIndex)
    }), columns.map(function (column) {
      var cellProps = (0, _utils.merge)({}, resolveProp(defaultCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultBodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.bodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      cellProps.style = _objectSpread({}, cellProps.style, {
        visibility: "hidden"
      });
      return _react["default"].createElement(_TableCell["default"], _extends({
        style: {
          visibility: "hidden"
        },
        key: "body-cell-placeholder-".concat(rowIndex, "-").concat(column.name)
      }, cellProps), "\xA0");
    }));
  })))), pagination && _react["default"].createElement(_TablePagination["default"], _extends({
    component: "div"
  }, pagination)));
}

MuiTable.propTypes = {
  addPlaceholderRows: _propTypes["default"].bool,
  bodyCellProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  bodyRowProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  cellProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  classes: _propTypes["default"].object,
  columns: _propTypes["default"].array,
  containerProps: _propTypes["default"].object,
  data: _propTypes["default"].array,
  headerCellProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  headerRowProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  includeHeaders: _propTypes["default"].bool,
  isCellHovered: _propTypes["default"].func,
  isCellSelected: _propTypes["default"].func,
  onCellClick: _propTypes["default"].func,
  onHeaderClick: _propTypes["default"].func,
  orderBy: _propTypes["default"].string,
  orderDirection: _propTypes["default"].string,
  pagination: _propTypes["default"].object,
  rowProps: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].func]),
  tableWrapperProps: _propTypes["default"].object,
  headerProps: _propTypes["default"].object,
  bodyProps: _propTypes["default"].object
};
var _default = MuiTable;
exports["default"] = _default;